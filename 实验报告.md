#实验报告

朱昱熹 2019011332 黄彬 2019011344 赵益良 2019011211

##分工说明：

朱昱熹：参与讨论和设计解题算法，实现解题算法雏形；设计并实现出题算法；完成整体代码框架；撰写实验报告。

黄彬：参与讨论和设计解题算法，设计并实现最终提交的解题算法；撰写实验报告解题算法设计思路部分。

赵益良：参与讨论和设计解题算法，实现解题算法雏形；撰写心得体会和大致历程。

 

##程序功能介绍：

程序用于实现数独出题和解题，可根据要求生成空格数达到一半、且有唯一解的数独，或判断解的个数并解出所给数独的可能解（多解只给出其中两个）。

 

##代码设计思路：

1. 程序整体代码：

除头文件和命名空间的声明外，程序由2个class和4个函数（不包括主函数）组成。其中，两个class分别对应于解题部分和出题部分，由两名同学分别完成，封装成class，并仅提供必需的接口供其余部分调用。4个函数供主函数调用，其中两个用于获取输入，另两个用于调用class中的函数解决题目问题。

函数原型及功能罗列如下：

| 函数原型                       | 功能                                                       |
| ------------------------------ | ---------------------------------------------------------- |
| int  get_command();            | 获取解题或是出题的命令符                                   |
| void input(int  sudoku[9][9]); | 输入与题目样式一致的数独，并将其转化为易于计算的纯数字格式 |
| void solve();                  | 调用DLX类解数独                                            |
| void build();                  | 调用BWR类出数独                                            |

 

2. 解题部分代码：

根据算法设计思路（展示在下一个部分），将整个解题过程封装在一个名为DLX的类中，提供必要的接口供程序其余部分调用。

各函数原型及功能罗列如下：

| 函数原型                            | 功能                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| private:                            |                                                              |
| void ins(int x, int row, int col)； | 在(row, col)处插入编号为x的节点                              |
| void del(int x)；                   | 删除x号节点                                                  |
| void back(int x)；                  | 恢复x号节点                                                  |
| void build()；                      | 构建初始Dancing Link                                         |
| bool init()；                       | 完成初始化后调用build()，根据输入的已填入数独的数用X算法消除行与列，如果原状态已经违反数独要求返回0，否则返回1 |
| void solve(int dep = 1)；           | 使用X算法填入第dep个数                                       |
| void fill(int *s)；                 | 根据X算法得到的某个解填好数独                                |
| void print()；                      | 输出数独                                                     |
| public:                             |                                                              |
| void output()；                     | 根据题目要求输出解                                           |
| void sol1()；                       | 填好第一个解                                                 |
| void sol2()；                       | 填好第二个解                                                 |
| DLX(int b[9][9])；                  | 初始化构造DLX                                                |

 

3. 出题部分代码：

根据出题算法设计思路（展示在下一个部分），将整个出题过程封装在一个名为BWR的类中，提供必要的接口供程序其余部分调用。

各函数原型及功能罗列如下：

| 函数原型                            | 功能                             |
| ----------------------------------- | -------------------------------- |
| private：                           |                                  |
| int static pos2block(int x, int y); | 将位置转换为block序号            |
| void build_raw_sudoku();            | 生成含有25个随机数的合法数独     |
| void next_sudoku(DLX * x);          | 根据解再添加3个随机数            |
| void show();                        | 按照要求的格式输出已经生成的数独 |
| public:                             |                                  |
| void build()                        | 生成符合要求的数独并输出         |

 

 

##解题算法设计思路：

1. 将数独转化为精确覆盖问题

精确覆盖问题描述如下：对于给定的01矩阵，问是否存在这样一个行集合，使得集合中每一列恰有一个“1”。

行代表数独的所有情况，每个格子能够填的数字为[1,9]，并且总共有81个格子，所以总的情况数为729种。

列代表问题的约束条件，[0, 81)列对应了81个格子是否被放置了数字。[81, 2*81)列分别对应了9行，每行[1, 9]个数字的放置情况；同理分别各用81列表示9个列和9个宫的情况。

这样问题就变成了精确覆盖问题（选出某些行并且满足每列的限制）。

2. 使用X算法解决精确覆盖问题（译自维基百科）：

   1. 如果矩阵A没有列（即空矩阵），则当前记录的解为一个可行解

   2. 否则选择矩阵A中“1”的个数最少的列c；（确定性选择）

   3. a.如果存在A[r][c]=1的行r，将行r放入可行解列表，进入步骤4)；   

      b.如果不存在A[r][c]=1的行r，则剩下的矩阵不可能完成精确覆盖，说明之前的选择有错（或者根本就无解），需要回溯，恢复此次删除的行和列，然后跳到步骤3)a；

   4. 对于所有的满足A[r][j]=1的列j:

      ①对于所有满足A[i][j]=1的行i，将行i从矩阵A中删除;

      ②将列j从矩阵A中删除；

   5. 转1)

3. 使用Dancing Link（十字交叉双向循环链表）优化X算法

在X算法中时间主要用于删除/恢复某行/某列，因此使用DL来加速这一过程。

将01矩阵中的每一个1视作一个节点，分别Link上下左右四个方向最近的节点，形成一个十字交叉双向链表，并且用列首节点和行首节点将最外侧的节点连成循环链表，形成Dancing Link。这样在删除某行或某列时就能快速找到X算法所需要找到的所有“1”的位置。

 

出题算法设计思路：

1. 使用随机数向数独随机位置填入随机数，但保证填入数字满足数独的要求，填入25个数字。

2. 利用DLX解出数独：
   1. 若数独无解，回到1.
   2. 若数独有唯一解，将其输出并返回
   3. 若数独有多解，进入3.

3. 根据数独的解向数独中再填入3个数，如果已经填入了37个数，则返回1.

4. 利用DLX解出数独：
   1. 若数独有唯一解，将其输出并返回
   2. 若数独有多解，重复3.

经过多次尝试将生成一组解。由于经过测试，大多数情况下解数独很快，故可以进行多次尝试。

 

大作业心得体会：（见附件1）

解题算法雏型代码：（见附件2、3）